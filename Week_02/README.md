学习笔记

### 哈希表

哈希表底层是用数组实现的，这也是其查找性能能够达到O(1)的关键。通过对放入的元素进行hash，得到一个整形值，然后对数组的长度进行取余操作，得到一个下标，放入对应位置即可。在查找的时候使用同样的hash函数，进行取余操作，从对应的下标去取元素即可。

再完美的hash函数也难免会出现哈希冲突的现象，即便不出现冲突，经过取余操作也是极有可能出现冲突的。解决的办法有线性探测法、链地址法等。

线性探测法是发现冲突后，线性的往后探测，寻找下一个下标，直到找到的位置没有元素为止。

链地址法是发现冲突后，在对应的位置使用链表将冲突的元素都串联起来。

常见的应用有：Java中的HashMap、HashSet等哈希集合，布隆过滤器，加密算法等。

### 树

树是特殊的图（单向无环），链表是特殊的树，二叉树是树的特殊实现，即每个节点最多两个出度（两个“叉”）

二叉搜索树：也叫二叉查找树，是一种特殊的二叉树，内部的所有元素都遵循根的值大于其左子树的所有节点，小于其右子树的所有节点，其中序遍历是有序的。查询的时间复杂度是O(logn)

### 堆

可以迅速找到一堆数中的最大值或最小值的一种数据结构，具体实现有多种，二叉堆只是其中一种，实现较为简单。Java中的PriorityQueue就是堆的一种实现。

二叉堆的特点是根节点大于其左子节点和右子节点（大根堆），或者根节点小于其左子节点和右子节点（小根堆）

堆排序：

- 建堆阶段：从最后一个非叶子节点开始，递归比较根节点和叶子节点的大小，使得每一个非叶子节点都比它的子节点大，此时根节点是最大的元素
- 排序阶段：每次弹出堆顶元素，与末尾元素交换（相当于删除了堆顶元素），将堆的大小减一后再次调整堆，将根节点再次调整为最大元素，循环即可。